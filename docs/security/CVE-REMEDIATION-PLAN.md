# CVE Remediation Plan - Trading Engine Security Overhaul

**Priority: CRITICAL** | **Timeline: Phase 1 (Week 1-2)** | **Status: IN PROGRESS**

## Executive Summary

This document outlines the complete remediation plan for 8 CVE-level vulnerabilities discovered in the trading engine. All vulnerabilities are classified as CRITICAL or HIGH severity and must be addressed immediately before production deployment.

---

## CVE-1: Hardcoded API Keys

**Severity:** CRITICAL
**CVSS Score:** 9.8 (Critical)
**Location:** `backend/cmd/server/main.go:23-24`, `backend/fix/gateway.go`

### Current State
```go
// VULNERABLE CODE
const OANDA_API_KEY = "977e1a77e25bac3a688011d6b0e845dd-8e3ab3a7682d9351af4c33be65e89b70"
const OANDA_ACCOUNT_ID = "101-004-37008470-002"

Password: getEnvOrDefault("YOFX_PASSWORD", "Brand#143")
```

### Impact
- **API key exposure** in source code and Git history
- **Unauthorized access** to OANDA trading account
- **Financial loss** from malicious trades
- **Compliance violations** (PCI-DSS, SOC 2)

### Remediation Steps

#### Step 1: Environment Variable Migration (Week 1, Day 1)
```go
// SECURE IMPLEMENTATION
import (
    "os"
    "github.com/joho/godotenv"
)

type Config struct {
    OandaAPIKey      string
    OandaAccountID   string
    YofxPassword     string
    JWTSecret        string
    DatabaseURL      string
    RedisURL         string
    TLSCertPath      string
    TLSKeyPath       string
}

func LoadConfig() (*Config, error) {
    // Load .env file (development only)
    if os.Getenv("ENVIRONMENT") != "production" {
        godotenv.Load()
    }

    cfg := &Config{
        OandaAPIKey:    requireEnv("OANDA_API_KEY"),
        OandaAccountID: requireEnv("OANDA_ACCOUNT_ID"),
        YofxPassword:   requireEnv("YOFX_PASSWORD"),
        JWTSecret:      requireEnv("JWT_SECRET"),
        DatabaseURL:    requireEnv("DATABASE_URL"),
        RedisURL:       requireEnv("REDIS_URL"),
        TLSCertPath:    requireEnv("TLS_CERT_PATH"),
        TLSKeyPath:     requireEnv("TLS_KEY_PATH"),
    }

    return cfg, nil
}

func requireEnv(key string) string {
    value := os.Getenv(key)
    if value == "" {
        log.Fatalf("[FATAL] Required environment variable %s is not set", key)
    }
    return value
}
```

#### Step 2: .env.example Update (Week 1, Day 1)
```bash
# Trading Engine Configuration - PRODUCTION

# CRITICAL: Never commit .env file to version control
# Generate secrets with: openssl rand -base64 32

# Server Configuration
PORT=7999
ENVIRONMENT=production
LOG_LEVEL=info

# JWT Authentication (MUST be 32+ bytes)
JWT_SECRET=<generate_with_openssl_rand_base64_32>

# OANDA Liquidity Provider (NEVER hardcode)
OANDA_API_KEY=<obtain_from_oanda_dashboard>
OANDA_ACCOUNT_ID=<your_oanda_account_id>

# YoFx FIX Connection
YOFX_PASSWORD=<obtain_from_yofx_support>
YOFX_SENDER_COMP_ID=<your_sender_comp_id>
YOFX_TARGET_COMP_ID=<yofx_target_comp_id>

# Database (PostgreSQL)
DATABASE_URL=postgres://username:password@localhost:5432/trading_engine?sslmode=require

# Redis Cache
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=<generate_with_openssl_rand_base64_32>

# TLS/SSL Certificates
TLS_CERT_PATH=/etc/ssl/certs/trading-engine.crt
TLS_KEY_PATH=/etc/ssl/private/trading-engine.key

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_REQUESTS_PER_MINUTE=60
RATE_LIMIT_BURST=10

# CORS Configuration
ALLOWED_ORIGINS=https://app.example.com,https://admin.example.com

# Vault Integration (Production)
VAULT_ENABLED=true
VAULT_ADDR=https://vault.example.com:8200
VAULT_TOKEN=<vault_token>
VAULT_SECRET_PATH=secret/trading-engine
```

#### Step 3: Vault Integration (Week 1, Day 2)
```go
package vault

import (
    "fmt"
    "github.com/hashicorp/vault/api"
)

type VaultClient struct {
    client *api.Client
    path   string
}

func NewVaultClient(addr, token, secretPath string) (*VaultClient, error) {
    config := api.DefaultConfig()
    config.Address = addr

    client, err := api.NewClient(config)
    if err != nil {
        return nil, fmt.Errorf("vault client creation failed: %w", err)
    }

    client.SetToken(token)

    return &VaultClient{
        client: client,
        path:   secretPath,
    }, nil
}

func (v *VaultClient) GetSecret(key string) (string, error) {
    secret, err := v.client.Logical().Read(v.path)
    if err != nil {
        return "", fmt.Errorf("vault read failed: %w", err)
    }

    if secret == nil || secret.Data == nil {
        return "", fmt.Errorf("secret not found: %s", key)
    }

    value, ok := secret.Data[key].(string)
    if !ok {
        return "", fmt.Errorf("invalid secret type for key: %s", key)
    }

    return value, nil
}

func (v *VaultClient) RotateSecret(key, newValue string) error {
    data := map[string]interface{}{
        key: newValue,
    }

    _, err := v.client.Logical().Write(v.path, data)
    if err != nil {
        return fmt.Errorf("vault write failed: %w", err)
    }

    log.Printf("[SECURITY] Secret rotated successfully: %s", key)
    return nil
}
```

#### Step 4: Secret Rotation Mechanism (Week 1, Day 3)
```go
package security

import (
    "crypto/rand"
    "encoding/base64"
    "time"
)

type SecretRotator struct {
    vault         *VaultClient
    rotationCycle time.Duration
}

func NewSecretRotator(vault *VaultClient, rotationCycle time.Duration) *SecretRotator {
    return &SecretRotator{
        vault:         vault,
        rotationCycle: rotationCycle,
    }
}

func (r *SecretRotator) Start() {
    ticker := time.NewTicker(r.rotationCycle)
    defer ticker.Stop()

    for range ticker.C {
        r.rotateAPIKeys()
    }
}

func (r *SecretRotator) rotateAPIKeys() {
    // Generate new JWT secret
    newJWTSecret := generateSecureSecret(32)
    if err := r.vault.RotateSecret("JWT_SECRET", newJWTSecret); err != nil {
        log.Printf("[ERROR] JWT secret rotation failed: %v", err)
        return
    }

    // Notify all active sessions to refresh tokens
    // Implementation depends on session manager
    log.Println("[SECURITY] JWT secret rotated - active sessions invalidated")
}

func generateSecureSecret(length int) string {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        log.Fatalf("[FATAL] Failed to generate secure random: %v", err)
    }
    return base64.URLEncoding.EncodeToString(bytes)
}
```

### Verification
- [ ] All hardcoded credentials removed from source code
- [ ] Git history rewritten to remove exposed secrets
- [ ] Vault integration tested in staging
- [ ] Secret rotation mechanism operational
- [ ] .env.example updated with all required variables
- [ ] Production secrets stored in Vault

---

## CVE-2: No Authentication/Authorization

**Severity:** CRITICAL
**CVSS Score:** 9.1 (Critical)
**Location:** All HTTP endpoints in `backend/api/server.go`

### Current State
```go
// VULNERABLE: No authentication required
http.HandleFunc("/api/positions/close", server.HandleClosePosition)
http.HandleFunc("/admin/deposit", apiHandler.HandleAdminDeposit)
```

### Impact
- **Unauthorized trading** - Anyone can place/close orders
- **Fund manipulation** - Anyone can deposit/withdraw funds
- **Account takeover** - No session validation
- **Compliance violations** - GDPR, KYC/AML bypass

### Remediation Steps

#### Step 1: JWT Middleware (Week 1, Day 2)
```go
package middleware

import (
    "context"
    "net/http"
    "strings"
    "github.com/epic1st/rtx/backend/auth"
)

type contextKey string

const UserContextKey contextKey = "user"

// AuthMiddleware validates JWT tokens
func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            http.Error(w, "Authorization header required", http.StatusUnauthorized)
            return
        }

        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
            return
        }

        token := parts[1]
        claims, err := auth.ValidateJWT(token)
        if err != nil {
            http.Error(w, "Invalid or expired token", http.StatusUnauthorized)
            return
        }

        // Add user to request context
        ctx := context.WithValue(r.Context(), UserContextKey, claims)
        next.ServeHTTP(w, r.WithContext(ctx))
    }
}

// RoleMiddleware enforces role-based access control
func RoleMiddleware(allowedRoles ...string) func(http.HandlerFunc) http.HandlerFunc {
    return func(next http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            user, ok := r.Context().Value(UserContextKey).(*auth.Claims)
            if !ok {
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
            }

            allowed := false
            for _, role := range allowedRoles {
                if user.Role == role {
                    allowed = true
                    break
                }
            }

            if !allowed {
                http.Error(w, "Forbidden - insufficient permissions", http.StatusForbidden)
                return
            }

            next.ServeHTTP(w, r)
        }
    }
}
```

#### Step 2: RBAC Implementation (Week 1, Day 3)
```go
package auth

// Role definitions
const (
    RoleSuperAdmin = "SUPER_ADMIN" // Full system access
    RoleAdmin      = "ADMIN"        // Broker management
    RoleBroker     = "BROKER"       // Client account management
    RoleTrader     = "TRADER"       // Trading only
    RoleViewer     = "VIEWER"       // Read-only access
)

// Permission matrix
var Permissions = map[string][]string{
    RoleSuperAdmin: {
        "admin:*",
        "trading:*",
        "account:*",
        "system:*",
    },
    RoleAdmin: {
        "admin:accounts:read",
        "admin:accounts:write",
        "admin:deposit",
        "admin:withdraw",
        "admin:bonus",
        "trading:*",
    },
    RoleBroker: {
        "account:read",
        "account:write",
        "trading:read",
    },
    RoleTrader: {
        "trading:order:create",
        "trading:order:cancel",
        "trading:position:read",
        "trading:position:close",
        "account:read",
    },
    RoleViewer: {
        "trading:read",
        "account:read",
    },
}

func HasPermission(role, permission string) bool {
    perms, ok := Permissions[role]
    if !ok {
        return false
    }

    for _, p := range perms {
        if matchPermission(p, permission) {
            return true
        }
    }

    return false
}

func matchPermission(pattern, permission string) bool {
    // Wildcard matching: admin:* matches admin:accounts:read
    if strings.HasSuffix(pattern, ":*") {
        prefix := strings.TrimSuffix(pattern, ":*")
        return strings.HasPrefix(permission, prefix)
    }
    return pattern == permission
}
```

#### Step 3: Protected Routes (Week 1, Day 4)
```go
// main.go - Secure route registration

// Public routes (no auth required)
http.HandleFunc("/health", handleHealth)
http.HandleFunc("/login", server.HandleLogin)

// Trader routes (requires TRADER role or higher)
http.HandleFunc("/api/orders/market",
    middleware.AuthMiddleware(
        middleware.RoleMiddleware(RoleTrader, RoleAdmin, RoleSuperAdmin)(
            apiHandler.HandlePlaceMarketOrder,
        ),
    ),
)

http.HandleFunc("/api/positions/close",
    middleware.AuthMiddleware(
        middleware.RoleMiddleware(RoleTrader, RoleAdmin, RoleSuperAdmin)(
            apiHandler.HandleClosePosition,
        ),
    ),
)

// Admin routes (requires ADMIN role or higher)
http.HandleFunc("/admin/deposit",
    middleware.AuthMiddleware(
        middleware.RoleMiddleware(RoleAdmin, RoleSuperAdmin)(
            apiHandler.HandleAdminDeposit,
        ),
    ),
)

http.HandleFunc("/admin/withdraw",
    middleware.AuthMiddleware(
        middleware.RoleMiddleware(RoleAdmin, RoleSuperAdmin)(
            apiHandler.HandleAdminWithdraw,
        ),
    ),
)

// SuperAdmin routes (requires SUPER_ADMIN role)
http.HandleFunc("/admin/execution-mode",
    middleware.AuthMiddleware(
        middleware.RoleMiddleware(RoleSuperAdmin)(
            handleExecutionMode,
        ),
    ),
)
```

#### Step 4: Session Management (Week 1, Day 5)
```go
package session

import (
    "crypto/rand"
    "encoding/base64"
    "sync"
    "time"
)

type Session struct {
    ID        string
    UserID    string
    Role      string
    CreatedAt time.Time
    ExpiresAt time.Time
    IP        string
    UserAgent string
}

type Manager struct {
    sessions map[string]*Session
    mu       sync.RWMutex
}

func NewManager() *Manager {
    mgr := &Manager{
        sessions: make(map[string]*Session),
    }

    // Start cleanup goroutine
    go mgr.cleanupExpired()

    return mgr
}

func (m *Manager) Create(userID, role, ip, userAgent string) (*Session, error) {
    sessionID, err := generateSessionID()
    if err != nil {
        return nil, err
    }

    session := &Session{
        ID:        sessionID,
        UserID:    userID,
        Role:      role,
        CreatedAt: time.Now(),
        ExpiresAt: time.Now().Add(24 * time.Hour),
        IP:        ip,
        UserAgent: userAgent,
    }

    m.mu.Lock()
    m.sessions[sessionID] = session
    m.mu.Unlock()

    return session, nil
}

func (m *Manager) Get(sessionID string) (*Session, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    session, ok := m.sessions[sessionID]
    if !ok || session.ExpiresAt.Before(time.Now()) {
        return nil, false
    }

    return session, true
}

func (m *Manager) Revoke(sessionID string) {
    m.mu.Lock()
    delete(m.sessions, sessionID)
    m.mu.Unlock()
}

func (m *Manager) cleanupExpired() {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()

    for range ticker.C {
        m.mu.Lock()
        now := time.Now()
        for id, session := range m.sessions {
            if session.ExpiresAt.Before(now) {
                delete(m.sessions, id)
            }
        }
        m.mu.Unlock()
    }
}

func generateSessionID() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}
```

### Verification
- [ ] All endpoints protected with authentication
- [ ] RBAC implemented and tested for all roles
- [ ] Session management operational
- [ ] JWT refresh token mechanism working
- [ ] Unauthorized access attempts logged
- [ ] OAuth2/SSO integration tested (if required)

---

## CVE-3: No HTTPS/TLS

**Severity:** HIGH
**CVSS Score:** 8.1 (High)
**Location:** `backend/cmd/server/main.go:545`

### Current State
```go
// VULNERABLE: HTTP only
http.ListenAndServe(":7999", nil)
```

### Impact
- **Credentials in plaintext** during transmission
- **API keys exposed** over network
- **Man-in-the-middle attacks** possible
- **Session hijacking** via packet sniffing
- **Compliance violations** (PCI-DSS requires TLS 1.2+)

### Remediation Steps

#### Step 1: TLS Configuration (Week 1, Day 4)
```go
package server

import (
    "crypto/tls"
    "net/http"
    "time"
)

type TLSConfig struct {
    CertPath    string
    KeyPath     string
    MinVersion  uint16
    CipherSuite []uint16
}

func NewTLSConfig(certPath, keyPath string) *tls.Config {
    return &tls.Config{
        MinVersion: tls.VersionTLS13, // TLS 1.3 only
        CipherSuites: []uint16{
            tls.TLS_AES_256_GCM_SHA384,
            tls.TLS_CHACHA20_POLY1305_SHA256,
            tls.TLS_AES_128_GCM_SHA256,
        },
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{
            tls.X25519,
            tls.CurveP256,
        },
    }
}

func StartSecureServer(handler http.Handler, port string, tlsConfig *tls.Config) error {
    srv := &http.Server{
        Addr:         ":" + port,
        Handler:      handler,
        TLSConfig:    tlsConfig,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // Add HSTS header
    handler = addSecurityHeaders(handler)

    log.Printf("[SECURITY] Starting HTTPS server on port %s (TLS 1.3)", port)
    return srv.ListenAndServeTLS(
        os.Getenv("TLS_CERT_PATH"),
        os.Getenv("TLS_KEY_PATH"),
    )
}

func addSecurityHeaders(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // HSTS: Force HTTPS for 1 year
        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")

        // Prevent clickjacking
        w.Header().Set("X-Frame-Options", "DENY")

        // XSS protection
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.Header().Set("X-XSS-Protection", "1; mode=block")

        // CSP
        w.Header().Set("Content-Security-Policy", "default-src 'self'")

        // Referrer policy
        w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

        next.ServeHTTP(w, r)
    })
}
```

#### Step 2: Let's Encrypt Integration (Week 1, Day 5)
```go
package certmanager

import (
    "crypto/tls"
    "golang.org/x/crypto/acme/autocert"
)

func NewAutoCertManager(domain, cacheDir string) *autocert.Manager {
    return &autocert.Manager{
        Prompt:      autocert.AcceptTOS,
        HostPolicy:  autocert.HostWhitelist(domain),
        Cache:       autocert.DirCache(cacheDir),
        Email:       "admin@" + domain,
    }
}

func StartWithAutoCert(handler http.Handler, domain string) error {
    certManager := NewAutoCertManager(domain, "/etc/letsencrypt/cache")

    tlsConfig := &tls.Config{
        GetCertificate: certManager.GetCertificate,
        MinVersion:     tls.VersionTLS13,
    }

    srv := &http.Server{
        Addr:      ":443",
        Handler:   handler,
        TLSConfig: tlsConfig,
    }

    // Redirect HTTP to HTTPS
    go redirectHTTPToHTTPS()

    log.Printf("[SECURITY] Starting HTTPS with Let's Encrypt for domain: %s", domain)
    return srv.ListenAndServeTLS("", "")
}

func redirectHTTPToHTTPS() {
    http.ListenAndServe(":80", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, "https://"+r.Host+r.RequestURI, http.StatusMovedPermanently)
    }))
}
```

#### Step 3: WebSocket Secure (WSS) (Week 1, Day 5)
```go
package ws

import (
    "crypto/tls"
    "net/http"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin: func(r *http.Request) bool {
        // Validate origin against allowed list
        origin := r.Header.Get("Origin")
        return isAllowedOrigin(origin)
    },
}

func ServeSecureWs(hub *Hub, w http.ResponseWriter, r *http.Request) {
    // Ensure connection is over TLS
    if r.TLS == nil {
        http.Error(w, "WSS required", http.StatusUpgradeRequired)
        return
    }

    // Validate TLS version
    if r.TLS.Version < tls.VersionTLS13 {
        http.Error(w, "TLS 1.3 required", http.StatusUpgradeRequired)
        return
    }

    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("[ERROR] WebSocket upgrade failed: %v", err)
        return
    }

    client := &Client{hub: hub, conn: conn, send: make(chan []byte, 256)}
    hub.register <- client

    go client.writePump()
    go client.readPump()
}
```

### Verification
- [ ] HTTPS server running on port 443
- [ ] TLS 1.3 enforced (no TLS 1.2 or lower)
- [ ] Let's Encrypt auto-renewal working
- [ ] HSTS headers present in all responses
- [ ] HTTP to HTTPS redirect functional
- [ ] WSS (secure WebSocket) operational
- [ ] SSL Labs test score: A+

---

## CVE-4: Default Admin Password

**Severity:** CRITICAL
**CVSS Score:** 9.8 (Critical)
**Location:** `backend/auth/service.go:31`

### Current State
```go
// VULNERABLE: Hardcoded password
hash, _ := bcrypt.GenerateFromPassword([]byte("password"), bcrypt.DefaultCost)
```

### Impact
- **Admin account takeover** with default credentials
- **Complete system compromise**
- **Unauthorized fund manipulation**
- **Trading platform shutdown**

### Remediation Steps

#### Step 1: Forced Password Change (Week 1, Day 2)
```go
package auth

type Account struct {
    ID                  int64
    Username            string
    PasswordHash        string
    Role                string
    MustChangePassword  bool    // New field
    PasswordChangedAt   time.Time
    FailedLoginAttempts int
    LockedUntil         *time.Time
    TwoFactorEnabled    bool
    TwoFactorSecret     string
}

func (s *Service) Login(username, password string) (string, *User, error) {
    account, err := s.getAccount(username)
    if err != nil {
        return "", nil, err
    }

    // Check account lockout
    if account.LockedUntil != nil && time.Now().Before(*account.LockedUntil) {
        return "", nil, errors.New("account locked due to failed login attempts")
    }

    // Verify password
    err = bcrypt.CompareHashAndPassword([]byte(account.PasswordHash), []byte(password))
    if err != nil {
        s.handleFailedLogin(account)
        return "", nil, errors.New("invalid credentials")
    }

    // Reset failed login attempts
    s.resetFailedAttempts(account)

    // Check if password change required
    if account.MustChangePassword {
        return "", nil, errors.New("password_change_required")
    }

    // Check if 2FA enabled
    if account.TwoFactorEnabled {
        return s.generateTwoFactorChallenge(account)
    }

    return s.generateToken(account)
}

func (s *Service) handleFailedLogin(account *Account) {
    account.FailedLoginAttempts++

    if account.FailedLoginAttempts >= 5 {
        lockUntil := time.Now().Add(30 * time.Minute)
        account.LockedUntil = &lockUntil

        log.Printf("[SECURITY] Account locked due to failed attempts: %s", account.Username)

        // Send alert email
        s.sendAccountLockEmail(account)
    }

    s.updateAccount(account)
}
```

#### Step 2: Password Policy (Week 1, Day 2)
```go
package security

import (
    "errors"
    "regexp"
    "unicode"
)

type PasswordPolicy struct {
    MinLength      int
    RequireUpper   bool
    RequireLower   bool
    RequireNumber  bool
    RequireSpecial bool
    MaxAge         time.Duration
    PreventReuse   int // Number of previous passwords to check
}

var DefaultPolicy = PasswordPolicy{
    MinLength:      12,
    RequireUpper:   true,
    RequireLower:   true,
    RequireNumber:  true,
    RequireSpecial: true,
    MaxAge:         90 * 24 * time.Hour, // 90 days
    PreventReuse:   5,
}

func ValidatePassword(password string, policy PasswordPolicy) error {
    if len(password) < policy.MinLength {
        return errors.New("password must be at least 12 characters")
    }

    var (
        hasUpper   bool
        hasLower   bool
        hasNumber  bool
        hasSpecial bool
    )

    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }

    if policy.RequireUpper && !hasUpper {
        return errors.New("password must contain at least one uppercase letter")
    }
    if policy.RequireLower && !hasLower {
        return errors.New("password must contain at least one lowercase letter")
    }
    if policy.RequireNumber && !hasNumber {
        return errors.New("password must contain at least one number")
    }
    if policy.RequireSpecial && !hasSpecial {
        return errors.New("password must contain at least one special character")
    }

    // Check against common passwords
    if isCommonPassword(password) {
        return errors.New("password is too common")
    }

    return nil
}

func isCommonPassword(password string) bool {
    common := []string{
        "password", "password123", "admin", "admin123",
        "12345678", "qwerty", "letmein", "welcome",
    }

    for _, p := range common {
        if strings.EqualFold(password, p) {
            return true
        }
    }

    return false
}
```

#### Step 3: Two-Factor Authentication (Week 1, Day 3)
```go
package auth

import (
    "github.com/pquerna/otp/totp"
    "encoding/base64"
    "image/png"
    "bytes"
)

func (s *Service) EnableTwoFactor(userID string) (string, []byte, error) {
    user, err := s.getUser(userID)
    if err != nil {
        return "", nil, err
    }

    // Generate TOTP secret
    key, err := totp.Generate(totp.GenerateOpts{
        Issuer:      "RTX Trading Engine",
        AccountName: user.Email,
        SecretSize:  32,
    })
    if err != nil {
        return "", nil, err
    }

    // Generate QR code
    var buf bytes.Buffer
    img, err := key.Image(200, 200)
    if err != nil {
        return "", nil, err
    }
    png.Encode(&buf, img)

    // Store secret (encrypted)
    user.TwoFactorSecret = key.Secret()
    s.updateUser(user)

    return key.Secret(), buf.Bytes(), nil
}

func (s *Service) ValidateTwoFactor(userID, code string) error {
    user, err := s.getUser(userID)
    if err != nil {
        return err
    }

    if !totp.Validate(code, user.TwoFactorSecret) {
        return errors.New("invalid 2FA code")
    }

    return nil
}
```

### Verification
- [ ] Default password disabled on first deployment
- [ ] Forced password change on first login
- [ ] Password policy enforced (12+ chars, complexity)
- [ ] Account lockout after 5 failed attempts
- [ ] 2FA/MFA operational and tested
- [ ] Password expiry (90 days) implemented

---

## CVE-5: No Data Persistence

**Severity:** HIGH
**CVSS Score:** 7.5 (High)
**Location:** All in-memory data structures

### Current State
- Orders, positions, accounts stored in memory maps
- Server restart = complete data loss
- No audit trail for regulatory compliance

### Impact
- **Financial loss** on server restart
- **Compliance violations** (no audit trail)
- **Recovery impossible** after crash
- **Regulatory fines** (MiFID II, Dodd-Frank)

### Remediation Steps

See separate document: `DATABASE-MIGRATION-PLAN.md` (handled by data persistence team)

Key requirements for security team:
- Connection pooling with pgx (prevent connection exhaustion)
- Prepared statements (prevent SQL injection)
- Row-level security (RLS) for multi-tenancy
- Encrypted connections (sslmode=require)
- Backup encryption at rest

---

## CVE-6: Memory Leaks

**Severity:** MEDIUM
**CVSS Score:** 6.5 (Medium)
**Location:** Unbounded maps/slices throughout codebase

### Current State
```go
// VULNERABLE: Unbounded growth
type Hub struct {
    clients    map[*Client]bool // Never cleaned up
    ticks      map[string][]Tick // Grows forever
}
```

### Impact
- **Service degradation** over time
- **Out of memory crashes**
- **DoS vulnerability** (attackers can exhaust memory)

### Remediation Steps

#### Step 1: Bounded Collections (Week 2, Day 1)
```go
package collections

import "container/list"

type BoundedMap struct {
    data     map[string]interface{}
    order    *list.List
    maxSize  int
    mu       sync.RWMutex
}

func NewBoundedMap(maxSize int) *BoundedMap {
    return &BoundedMap{
        data:    make(map[string]interface{}),
        order:   list.New(),
        maxSize: maxSize,
    }
}

func (m *BoundedMap) Set(key string, value interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()

    // If key exists, update and move to front
    if _, exists := m.data[key]; exists {
        m.data[key] = value
        return
    }

    // If at capacity, remove oldest
    if m.order.Len() >= m.maxSize {
        oldest := m.order.Back()
        m.order.Remove(oldest)
        delete(m.data, oldest.Value.(string))
    }

    // Add new entry
    m.data[key] = value
    m.order.PushFront(key)
}
```

#### Step 2: Context-Based Cleanup (Week 2, Day 1)
```go
package ws

import "context"

type Hub struct {
    clients    map[*Client]bool
    register   chan *Client
    unregister chan *Client
    ctx        context.Context
    cancel     context.CancelFunc
}

func NewHub() *Hub {
    ctx, cancel := context.WithCancel(context.Background())

    return &Hub{
        clients:    make(map[*Client]bool),
        register:   make(chan *Client),
        unregister: make(chan *Client),
        ctx:        ctx,
        cancel:     cancel,
    }
}

func (h *Hub) Run() {
    cleanupTicker := time.NewTicker(5 * time.Minute)
    defer cleanupTicker.Stop()

    for {
        select {
        case client := <-h.register:
            h.clients[client] = true

        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }

        case <-cleanupTicker.C:
            h.cleanupDeadClients()

        case <-h.ctx.Done():
            return
        }
    }
}

func (h *Hub) cleanupDeadClients() {
    for client := range h.clients {
        if !client.IsAlive() {
            h.unregister <- client
        }
    }
}
```

#### Step 3: Memory Limits (Week 2, Day 2)
```go
package server

import (
    "runtime"
    "runtime/debug"
)

func ConfigureMemoryLimits() {
    // Set max memory to 2GB
    debug.SetMemoryLimit(2 * 1024 * 1024 * 1024)

    // Set GOGC to 50 (more aggressive GC)
    debug.SetGCPercent(50)

    // Monitor memory usage
    go monitorMemory()
}

func monitorMemory() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    var m runtime.MemStats

    for range ticker.C {
        runtime.ReadMemStats(&m)

        usedMB := m.Alloc / 1024 / 1024

        log.Printf("[MEMORY] Alloc=%d MB, TotalAlloc=%d MB, Sys=%d MB, NumGC=%d",
            usedMB, m.TotalAlloc/1024/1024, m.Sys/1024/1024, m.NumGC)

        // Alert if over threshold
        if usedMB > 1500 {
            log.Printf("[WARNING] High memory usage detected: %d MB", usedMB)
            // Trigger graceful degradation
        }
    }
}
```

### Verification
- [ ] All unbounded maps replaced with bounded versions
- [ ] Goroutines cleaned up on context cancellation
- [ ] Memory limits configured
- [ ] Memory monitoring operational
- [ ] Load testing shows stable memory usage

---

## CVE-7: No Rate Limiting

**Severity:** HIGH
**CVSS Score:** 7.5 (High)
**Location:** All HTTP endpoints

### Current State
- No request throttling
- No IP-based limits
- Vulnerable to DDoS attacks

### Impact
- **Service unavailability** from DDoS
- **Resource exhaustion** from API abuse
- **Brute force attacks** on login endpoint

### Remediation Steps

#### Step 1: Token Bucket Rate Limiter (Week 2, Day 2)
```go
package ratelimit

import (
    "golang.org/x/time/rate"
    "sync"
    "net"
    "net/http"
)

type RateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
    rate     rate.Limit
    burst    int
}

func NewRateLimiter(requestsPerMinute int, burst int) *RateLimiter {
    return &RateLimiter{
        limiters: make(map[string]*rate.Limiter),
        rate:     rate.Limit(requestsPerMinute) / 60,
        burst:    burst,
    }
}

func (rl *RateLimiter) getLimiter(ip string) *rate.Limiter {
    rl.mu.Lock()
    defer rl.mu.Unlock()

    limiter, exists := rl.limiters[ip]
    if !exists {
        limiter = rate.NewLimiter(rl.rate, rl.burst)
        rl.limiters[ip] = limiter
    }

    return limiter
}

func (rl *RateLimiter) Middleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }

        limiter := rl.getLimiter(ip)

        if !limiter.Allow() {
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    }
}
```

#### Step 2: Adaptive Rate Limiting (Week 2, Day 3)
```go
package ratelimit

type TierConfig struct {
    Name           string
    RequestsPerMin int
    Burst          int
}

var RateLimitTiers = map[string]TierConfig{
    "SUPER_ADMIN": {
        Name:           "SuperAdmin",
        RequestsPerMin: 1000,
        Burst:          100,
    },
    "ADMIN": {
        Name:           "Admin",
        RequestsPerMin: 500,
        Burst:          50,
    },
    "TRADER": {
        Name:           "Trader",
        RequestsPerMin: 200,
        Burst:          20,
    },
    "VIEWER": {
        Name:           "Viewer",
        RequestsPerMin: 60,
        Burst:          10,
    },
    "ANONYMOUS": {
        Name:           "Anonymous",
        RequestsPerMin: 10,
        Burst:          2,
    },
}

func (rl *RateLimiter) AdaptiveMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // Extract user role from JWT
        role := "ANONYMOUS"
        if user, ok := r.Context().Value(middleware.UserContextKey).(*auth.Claims); ok {
            role = user.Role
        }

        config := RateLimitTiers[role]

        ip, _, _ := net.SplitHostPort(r.RemoteAddr)
        key := fmt.Sprintf("%s:%s", ip, role)

        limiter := rl.getTieredLimiter(key, config)

        if !limiter.Allow() {
            w.Header().Set("X-RateLimit-Limit", strconv.Itoa(config.RequestsPerMin))
            w.Header().Set("X-RateLimit-Remaining", "0")
            w.Header().Set("Retry-After", "60")
            http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    }
}
```

#### Step 3: IP Blacklisting (Week 2, Day 3)
```go
package security

type Blacklist struct {
    ips       map[string]time.Time
    mu        sync.RWMutex
    threshold int
    window    time.Duration
}

func NewBlacklist(threshold int, window time.Duration) *Blacklist {
    bl := &Blacklist{
        ips:       make(map[string]time.Time),
        threshold: threshold,
        window:    window,
    }

    go bl.cleanup()

    return bl
}

func (bl *Blacklist) Add(ip string) {
    bl.mu.Lock()
    defer bl.mu.Unlock()

    bl.ips[ip] = time.Now().Add(bl.window)

    log.Printf("[SECURITY] IP blacklisted: %s until %v", ip, bl.ips[ip])
}

func (bl *Blacklist) IsBlacklisted(ip string) bool {
    bl.mu.RLock()
    defer bl.mu.RUnlock()

    expiry, exists := bl.ips[ip]
    if !exists {
        return false
    }

    return time.Now().Before(expiry)
}

func (bl *Blacklist) cleanup() {
    ticker := time.NewTicker(1 * time.Minute)
    defer ticker.Stop()

    for range ticker.C {
        bl.mu.Lock()
        now := time.Now()
        for ip, expiry := range bl.ips {
            if now.After(expiry) {
                delete(bl.ips, ip)
            }
        }
        bl.mu.Unlock()
    }
}
```

### Verification
- [ ] Rate limiting active on all endpoints
- [ ] Adaptive limits based on user tier working
- [ ] DDoS protection tested (load testing)
- [ ] IP blacklisting operational
- [ ] WebSocket connection limits enforced

---

## Implementation Timeline

| Week | Days | CVE | Tasks | Status |
|------|------|-----|-------|--------|
| 1 | 1 | CVE-1 | Environment variables, .env.example | ⏳ Pending |
| 1 | 1-2 | CVE-1 | Vault integration | ⏳ Pending |
| 1 | 2-3 | CVE-2 | JWT middleware, RBAC | ⏳ Pending |
| 1 | 3-4 | CVE-2 | Protected routes, session mgmt | ⏳ Pending |
| 1 | 4-5 | CVE-3 | TLS config, Let's Encrypt | ⏳ Pending |
| 1 | 5 | CVE-3 | WSS implementation | ⏳ Pending |
| 1 | 2 | CVE-4 | Password policy, forced change | ⏳ Pending |
| 1 | 3 | CVE-4 | 2FA implementation | ⏳ Pending |
| 2 | 1-2 | CVE-6 | Bounded collections, memory limits | ⏳ Pending |
| 2 | 2-3 | CVE-7 | Rate limiting, IP blacklist | ⏳ Pending |

---

## Success Metrics

### Security Scorecard
- [ ] **npm audit / go mod verify**: 0 high/critical vulnerabilities
- [ ] **SSL Labs Test**: A+ rating
- [ ] **OWASP ZAP Scan**: 0 high-risk findings
- [ ] **Penetration Test**: No critical findings
- [ ] **Compliance Audit**: Pass PCI-DSS, SOC 2

### Performance Metrics
- [ ] **Authentication latency**: <50ms (JWT validation)
- [ ] **TLS handshake**: <100ms
- [ ] **Rate limiter overhead**: <5ms per request
- [ ] **Memory usage**: Stable under load (no leaks)

---

## Rollback Plan

If critical issues discovered during deployment:

1. **Immediate**: Revert to previous version (blue-green deployment)
2. **Emergency**: Disable problematic feature via feature flag
3. **Communication**: Notify stakeholders within 15 minutes
4. **Root Cause Analysis**: Complete within 24 hours
5. **Fix**: Deploy hotfix within 48 hours

---

## Security Testing Checklist

### Pre-Deployment
- [ ] Static analysis (gosec, semgrep)
- [ ] Dependency scan (go mod verify)
- [ ] Secret scanning (trufflehog, git-secrets)
- [ ] SAST (Snyk Code, SonarQube)

### Post-Deployment
- [ ] DAST (OWASP ZAP, Burp Suite)
- [ ] Penetration testing (external firm)
- [ ] Red team exercise
- [ ] Bug bounty program launch

---

**Document Owner:** Security Architect
**Last Updated:** 2026-01-18
**Next Review:** 2026-01-25
